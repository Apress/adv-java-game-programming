     package com.croftsoft.core.util.jlex;

     import java.io.*;
     import java.text.*;
     import java.util.*;

     /*********************************************************************
     * Test TokenScanner.
     *
     * <B>Reference:</B>
     *
     * <P>
     *
     * "JLex: A Lexical Analyzer Generator for Java"<BR>
     * <A HREF="http://www.cs.princeton.edu/~appel/modern/java/JLex/">
     * http://www.cs.princeton.edu/~appel/modern/java/JLex/</A>
     *
     * @author
     *   <A HREF="http://www.alumni.caltech.edu/~croft/">David W. Croft</A>
     * @version
     *   1999-02-11
     *********************************************************************/

     //////////////////////////////////////////////////////////////////////
     // Portions of this code machine-generated by JLex.
     //////////////////////////////////////////////////////////////////////

%%

%public
%class       TestTokenScanner
%implements  TokenScanner
%function    nextToken
%type        Token

%line
%char

%state STATE_NA
%state STATE_SE
%state STATE_DB
%state STATE_AD
%state STATE_P1
%state STATE_P2
%state STATE_P3

WHITE_SPACE_CHAR=[\ \r\n\t\b\012]
TAG_NA="/NA"
TAG_SE="/SE"
TAG_DB="/DB"
TAG_AD="/AD"
TAG_PA="/PA"
TAG_EN="/EN"

%{
     //////////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////////

     private static final String [ ]  TEST_DATA = {

         "/NA Peter Smith\r\n"
       + "/SE M /DB March 4, 1999\r\n"
       + "/AD 500 Pine St, Morgantown, WV\r\n"
       + "/PA Ann Mark\r\n"
       + "/EN\r\n"
       + "/NA Error\r\n",

         "/NA Peter Smith\n"
       + "/PA Ann Mark\n"
       + "/AD 500 Pine St, Morgantown, WV\n"
       + "/SE M /DB Mar 4, 1999\n"
       + "/EN\n"
       + "/NA Error\n",

         "/NA Peter Smith\r"
       + "/SE M /DB 4 March, 1999\r"
       + "/AD 500 Pine St, Morgantown, WV\r"
       + "/PA Ann Mark\r"
       + "/EN\r"
       + "/NA Error\r",

         "/NA Peter Smith\r\n"
       + "/SE M /DB 4 Mar, 1999\r\n"
       + "/AD 500 Pine St, Morgantown, WV\r\n"
       + "/PA Ann Mark\r\n"
       + "/EN\r\n"
       + "/NA Error\r\n",

         "/NA Peter Smith\r\n"
       + "/SE M /DB 3-4-1999\r\n"
       + "/AD 500 Pine St, Morgantown, WV\r\n"
       + "/PA Ann Mark\r\n"
       + "/EN\r\n"
       + "/NA Error\r\n",

         "/EN\r\n"
       + "/NA Peter Smith\r\n"
       + "/SE M /DB 3-4-1999\r\n"
       + "/AD 500 Pine St, Morgantown, WV\r\n"
       + "/PA Ann Mark\r\n",

         "/NA Jane Smith/SE F/DB 3-4-1999/PA Joe" };

     private static final String  DATE_PATTERN = "MMMM d, yyyy";

     //////////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////////

     public static void  main ( String [ ]  args )
       throws Exception
     //////////////////////////////////////////////////////////////////////
     {
       for ( int  i = 0; i < TEST_DATA.length; i++ )
       {
         System.out.println ( "" );
         test ( TEST_DATA [ i ] );
       }
     }

     public static void  test ( String  testText )
       throws Exception
     //////////////////////////////////////////////////////////////////////
     {
       Reader  reader = new StringReader ( testText );

       TokenScanner  tokenScanner = new TestTokenScanner ( reader );

       Token  token = null;

       String   name      = null;
       Boolean  isMale    = null;
       String   dateBirth = null;
       String   address   = null;
       String   parent1   = null;
       String   parent2   = null;

       loop:
       while ( ( token = tokenScanner.nextToken ( ) ) != null )
       {
         switch ( token.id )
         {
           case 0:
             break loop;
           case 1:
             name = token.text;
             break;
           case 2:
             isMale = parseGender ( token.text );
             break;
           case 3:
             dateBirth = reformatDateText ( token.text, DATE_PATTERN );
             break;
           case 4:
             address = token.text;
             break;
           case 5:
             parent1 = token.text;
             break;
           case 6:
             parent2 = token.text;
             break;
         }
       }

       printData ( name, isMale, dateBirth, address, parent1, parent2 );
     }

     public static Boolean  parseGender ( String  gender )
     //////////////////////////////////////////////////////////////////////
     {
       if ( gender.startsWith ( "M" ) || gender.startsWith ( "m" ) )
       {
         return new Boolean ( true );
       }

       if ( gender.startsWith ( "F" ) || gender.startsWith ( "f" ) )
       {
         return new Boolean ( false );
       }

       return null;
     }

     public static String  reformatDateText (
       String  dateText, String  pattern )
     //////////////////////////////////////////////////////////////////////
     {
       Date  date = parseDateText ( dateText );
       if ( date == null ) return null;
       DateFormat  dateFormat = new SimpleDateFormat ( pattern );
       return dateFormat.format ( date );
     }

     public static Date  parseDateText ( String  dateText )
     //////////////////////////////////////////////////////////////////////
     {
       Date  date = null;

       DateFormat  dateFormat = DateFormat.getDateInstance ( );

       try
       {
         date = dateFormat.parse ( dateText );
       }
       catch ( ParseException  ex )
       {
       }

       if ( date != null ) return date;

       dateFormat = new SimpleDateFormat ( "M-d-yyyy" );

       try
       {
         date = dateFormat.parse ( dateText );
       }
       catch ( ParseException  ex )
       {
       }

       if ( date != null ) return date;

       dateFormat = new SimpleDateFormat ( "d MMM, yyyy" );

       try
       {
         date = dateFormat.parse ( dateText );
       }
       catch ( ParseException  ex )
       {
       }

       return date;
     }

     public static void  printData (
       String  name,
       Boolean  isMale,
       String   dateBirth,
       String   address,
       String   parent1,
       String   parent2 )
     //////////////////////////////////////////////////////////////////////
     {
       System.out.println ( ( name != null ? name : "[name unknown]" )
         + " was born on "
         + ( dateBirth != null ? dateBirth : "[date unknown]" ) + "." );

       if ( address != null )
       {
         System.out.println ( ( isMale == null ? "He/She" :
           ( isMale.booleanValue ( ) ? "He" : "She" ) )
           + " lives at " + address + "." );
       }

       if ( parent1 != null )
       {
         System.out.println ( ( isMale == null ? "His/Her" :
           ( isMale.booleanValue ( ) ? "His" : "Her" ) )
           + " "
           + ( parent2 != null ? "parents are" : "parent is" )
           + " " + parent1
           + ( parent2 != null ? " and " + parent2 : "" )
           + "." );
       }
     }

     //////////////////////////////////////////////////////////////////////
     // Assumes only tags have a forward slash character.
     // Assumes parent names have no white space.
     //////////////////////////////////////////////////////////////////////

%}

%%

<YYINITIAL> {TAG_NA}{WHITE_SPACE_CHAR}+             { yybegin ( STATE_NA ); }
<YYINITIAL> {TAG_SE}{WHITE_SPACE_CHAR}+             { yybegin ( STATE_SE ); }
<YYINITIAL> {TAG_DB}{WHITE_SPACE_CHAR}+             { yybegin ( STATE_DB ); }
<YYINITIAL> {TAG_AD}{WHITE_SPACE_CHAR}+             { yybegin ( STATE_AD ); }
<YYINITIAL> {TAG_PA}{WHITE_SPACE_CHAR}+             { yybegin ( STATE_P1 ); }
<YYINITIAL> {TAG_EN}{WHITE_SPACE_CHAR}+             { return new Token ( 0 ); }
<YYINITIAL> {TAG_EN}$                               { return new Token ( 0 ); }
<STATE_NA>  [^\/\ \r\n\t\b\012][^\/\r\n\t\b\012]*   { yybegin ( YYINITIAL ); return new Token ( 1, yytext ( ) ); }
<STATE_SE>  [^\/\ \r\n\t\b\012][^\/\r\n\t\b\012]*   { yybegin ( YYINITIAL ); return new Token ( 2, yytext ( ) ); }
<STATE_DB>  [^\/\ \r\n\t\b\012][^\/\r\n\t\b\012]*   { yybegin ( YYINITIAL ); return new Token ( 3, yytext ( ) ); }
<STATE_AD>  [^\/\ \r\n\t\b\012][^\/\r\n\t\b\012]*   { yybegin ( YYINITIAL ); return new Token ( 4, yytext ( ) ); }
<STATE_P1>  [^\/\ \r\n\t\b\012]+                    { yybegin ( STATE_P2  ); return new Token ( 5, yytext ( ) ); }
<STATE_P2>  {WHITE_SPACE_CHAR}+                     { yybegin ( STATE_P3  ); }
<STATE_P3>  [^\/\ \r\n\t\b\012]+                    { yybegin ( YYINITIAL ); return new Token ( 6, yytext ( ) ); }
            (.|\n)                                  { yybegin ( YYINITIAL ); }

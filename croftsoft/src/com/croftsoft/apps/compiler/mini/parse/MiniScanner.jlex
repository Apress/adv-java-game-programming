     package com.croftsoft.apps.compiler.mini.parse;

     import java.io.*;
     import java.text.*;
     import java.util.*;

     import java_cup.runtime.*;

     /*********************************************************************
     * Token scanner for the Mini programming language.
     *
     * <B>Reference:</B>
     *
     * <P>
     *
     * "JLex: A Lexical Analyzer Generator for Java"<BR>
     * <A HREF="http://www.cs.princeton.edu/~appel/modern/java/JLex/">
     * http://www.cs.princeton.edu/~appel/modern/java/JLex/</A>
     *
     * @author
     *   <A HREF="http://www.alumni.caltech.edu/~croft/">David W. Croft</A>
     * @version
     *   1999-04-24
     *********************************************************************/

     //////////////////////////////////////////////////////////////////////
     // Portions of this code machine-generated by JLex.
     //////////////////////////////////////////////////////////////////////

%%

%public

%class       MiniScanner
%implements  MiniSymbols, CUPTokenScanner
%function    nextToken
%type        Symbol

%line
%char
%cup

%eofval{

  return new Symbol ( EOF );

%eofval}

WHITE_SPACE_CHAR=[\ \r\n\t\b\012]

BEGIN="begin"
CALL="call"
DO="do"
ELSE="else"
END="end"
IF="if"
INTEGER="integer"
FI="fi"
PROCEDURE="procedure"
READ="read"
THEN="then"
TO="to"
WHILE="while"
WRITE="write"

LETTER=[a-z]
DIGIT=[0-9]

CONSTANT={DIGIT}+
NAME={LETTER}({LETTER}|{DIGIT})*

SEMICOLON=";"
LPAREN="("
RPAREN=")"
COMMA=","

EXP="^"

TIMES="*"
DIVIDE="/"
MOD="%"

PLUS="+"
MINUS="-"

GE=">="
LE="<="
GT=">"
LT="<"

EQ="="
NE="<>"

ASSIGN=":="

NONNEWLINE_WHITE_SPACE_CHAR=[\ \t\b\012]
STRING_TEXT=(\\\"|[^\n\"]|\\{WHITE_SPACE_CHAR}+\\)*
COMMENT_TEXT=([^/*\n]|[^*\n]"/"[^*\n]|[^/\n]"*"[^/\n]|"*"[^/\n]|"/"[^*\n])*


%{
     //////////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////////

     private static final String [ ]  TEST_FILES = {
         "../test/Test.mini" };

     //////////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////////

     public static void  main ( String [ ]  args )
       throws Exception
     //////////////////////////////////////////////////////////////////////
     {
       for ( int  i = 0; i < TEST_FILES.length; i++ )
       {
         test ( new FileReader ( TEST_FILES [ i ] ) );
       }
     }

     public static void  test ( Reader  reader )
       throws Exception
     //////////////////////////////////////////////////////////////////////
     {
       MiniScanner  miniScanner = new MiniScanner ( reader );

       Symbol  symbol = null;

       loop:
       while ( ( symbol = miniScanner.nextToken ( ) ).sym != EOF )
       {
         System.out.println (
           "Symbol:  " + symbol + "  Value:  " + symbol.value );
       }
     }

     public static Symbol  scanConstant ( String  text )
     //////////////////////////////////////////////////////////////////////
     {
       try
       {
         return new Symbol ( CONSTANT, new Integer ( text ) );
       }
       catch ( NumberFormatException  ex )
       {
         return null;
       }
     }

     //////////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////////

%}

%%

<YYINITIAL> {BEGIN}     { return new Symbol ( BEGIN     ); }
<YYINITIAL> {CALL}      { return new Symbol ( CALL      ); }
<YYINITIAL> {DO}        { return new Symbol ( DO        ); }
<YYINITIAL> {ELSE}      { return new Symbol ( ELSE      ); }
<YYINITIAL> {END}       { return new Symbol ( END       ); }
<YYINITIAL> {IF}        { return new Symbol ( IF        ); }
<YYINITIAL> {INTEGER}   { return new Symbol ( INTEGER   ); }
<YYINITIAL> {FI}        { return new Symbol ( FI        ); }
<YYINITIAL> {PROCEDURE} { return new Symbol ( PROCEDURE ); }
<YYINITIAL> {READ}      { return new Symbol ( READ      ); }
<YYINITIAL> {THEN}      { return new Symbol ( THEN      ); }
<YYINITIAL> {TO}        { return new Symbol ( TO        ); }
<YYINITIAL> {WHILE}     { return new Symbol ( WHILE     ); }
<YYINITIAL> {WRITE}     { return new Symbol ( WRITE     ); }

<YYINITIAL> {NAME}      { return new Symbol ( NAME, yytext ( ) ); }
<YYINITIAL> {CONSTANT}  { return scanConstant ( yytext ( ) ); }

<YYINITIAL> {SEMICOLON} { return new Symbol ( SEMICOLON ); }
<YYINITIAL> {LPAREN}    { return new Symbol ( LPAREN    ); }
<YYINITIAL> {RPAREN}    { return new Symbol ( RPAREN    ); }
<YYINITIAL> {COMMA}     { return new Symbol ( COMMA     ); }

<YYINITIAL> {EXP}       { return new Symbol ( EXP       ); }

<YYINITIAL> {TIMES}     { return new Symbol ( TIMES     ); }
<YYINITIAL> {DIVIDE}    { return new Symbol ( DIVIDE    ); }
<YYINITIAL> {MOD}       { return new Symbol ( MOD       ); }

<YYINITIAL> {PLUS}      { return new Symbol ( PLUS      ); }
<YYINITIAL> {MINUS}     { return new Symbol ( MINUS     ); }

<YYINITIAL> {GE}        { return new Symbol ( GE        ); }
<YYINITIAL> {LE}        { return new Symbol ( LE        ); }
<YYINITIAL> {GT}        { return new Symbol ( GT        ); }
<YYINITIAL> {LT}        { return new Symbol ( LT        ); }

<YYINITIAL> {EQ}        { return new Symbol ( EQ        ); }
<YYINITIAL> {NE}        { return new Symbol ( NE        ); }

<YYINITIAL> {ASSIGN}    { return new Symbol ( ASSIGN    ); }

            (.|\n)      { yybegin ( YYINITIAL ); }
